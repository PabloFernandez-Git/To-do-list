To do list!

1. Configuración inicial

Importar 'styled-components'

Importar los estilos globales
import { createGlobalStyle } from 'styled-components'

Dentro de 'src' crear la carpeta 'styles' que contendra 'colors.js' donde tendremos los colores que usaremos en nuestra aplicacion.

Importar 'colors.js' donde necesitemos usarlos
import allColors from './styles/colors'

Crear en 'App.jsx' los estilos globales de la aplicacion

Recordar que para usar el componente <GlobalSyle /> debemos agregarlo como si fuera un componente mas (solo es necesario un tag con autocierre)

Recordar usar <Fragment></Fragment> o <></> para utilizar varios tags en un mismo render.


2. Formulario - Input text

Crear un componente donde tendremos nuestro formulario.
Realizar las importaciones necesarias (React, 'styled-components' y 'colors.js')

Utilizando 'styled-components' crear los componentes necesarios: Input, Button y ColorsContainer.


3. Formulario - Creando los inputs radio

Creamos un componente para mostrar los colores que podemos añadirle a nuestras tareas utilizando un input y un label.


4. Formulario - Componente de colores

Darle color a cada input y asociar el label con el input.

Destructurar las props y states para poder usarlos.

Truco css: usar un input asociado a un label y luego ocultar el input para una mejor presentacion.

const InputRadio = styled.input`
    display: none;
    &:checked + label {
        border: 1px solid #fff; 
    } 
`

Informar a nuestro 'app' cuando estamos cambiando el color para usarlo en nuestras tareas.

Crear en nuestro app un state para indicar cual es el color que esta seleccionado.

state = {
    colorSelected: allColors.colors[0]
}

De esta forma le damos un color por defecto que luego podemos cambiar usando un evento/manejador de evento (funcion).

handleChangeColor = (color) => {
    this.setState({ colorSelected: color })
}


Dentro del form creamos el evento personalizado y, de esta forma, tenemos un evento personalizado que llama a la funcion creada en el app.

<FormTask
    handleChangeColor={this.handleChangeColor}
    handleSubmit={this.handleSubmit}
/>


Ahora dentro de <ColorsContainer> (FormTask.jsx) ya podemos usar esa funcion porque se la estamos enviando como prop dese app.jsx

Dentro del <ColorBox> (de FormTask.jsx) necesitamos enviar esta prop para poder utilizarla en el componente ColorBox

<ColorBox handleChangeColor={handleChangeColor} color={color} /> 

Y ahora, ya dentro del componente ColorBox, tenemos libertad para usar esa prop (handleChangeColor)

Usando 'onChange' que es el evento que se dispara cuando cambiamos el input, le indicamos que llame a 'handleChangeColor'.
Para poder enviarle un parametro (en este caso un color) pasamos una arrow function y ejecutamos la funcion pasandole el color que estamos enviando como prop. 

const ColorBox = ( {color, handleChangeColor} ) => (
    <>
        <InputRadio
            id={color} 
            type="radio" 
            name="color"
            onChange={ () => handleChangeColor(color)} 
        />
        <LabelColor htmlFor={color} color={color}></LabelColor>
    </>
)


Estamos enviando el evento personalizado a traves del formulario y del formulario al 'ColorBox'.

Por ultimo debemos evitar el comportamiento por default que tiene el formulario (recargarse)

handleSubmit = (e) => {
    e.preventDefault()
}


5. Color por defecto

- Establecer un key unico para el map (FormTask.jsx)
(Siempre que usemos un .map para recorrer un array este necesita un id en React)

Descargar 'shortid' usando npm
import { generate as id } from 'shortid'
key={id()}


- Establecer que por defecto el primer elemento este marcado

Al haber agregado la funcion 'onChange' ya no tenemos el estado por defecto en el formulario (inputs)

Para recuperar esta funcionalidad tenemos dos propiedades: checked o defaulchecked

En nuestro 'app.jsx' destructuramos colorSelected para poder enviarlo hasta el 'ColorBox'

const {colorSelected} = this.state

Una vez destructurado lo pasamos dentro del formulario.

<FormTask
    handleChangeColor={this.handleChangeColor}
    handleSubmit={this.handleSubmit}
    colorSelected={colorSelected}
/>

Ahora que ya lo tenemos en el formulario podemos usar 'colorSelected' para establecer si tiene que estar marcado o no.

En 'FormTask' creamos una prop llamada 'isChecked' para saber si este componente debe estar seleccionado o no.
Antes destructuramos la prop para poder usarla.

const FormTask = ({ handleChangeColor, handleSubmit, colorSelected }) => ()

isChecked={colorSelected === color}

En el 'isChecked' necesitamos enviar un booleano para saber si esta marcado o no; por lo tanto solo tenemos que preguntarle si colorSelected es igual a color.

Eso significara que cuando el color seleccionado sea igual al color que esta renderizando o a la caja de color que este pintando en ese caso si queremos que sea 'checked'.

Por ultimo en 'ColorBox' destructuramos 'isChecked' y le decimos que el defaulchecked es igual a 'isChecked'.
De esta forma recuperamos la funcionalidad.
El primer color queda marcado por defecto al montar el componente y podemos seleccionar los demas si asi lo quisieramos.


const ColorBox = ( {color, handleChangeColor, isChecked} ) => ()

defaultChecked={isChecked}


6. Creando componente task

En nuestro 'app.jsx' creamos en el estado un array de tareas que va a ser el que controle como se van a pintar las tareas.

state = {
    colorSelected: allColors.colors[0],
    tasks: [
        {
            title: 'Aprender react',
            color: allColors.colors[0],
            done: false
        }
    ]
}

Esto va a ser un array de objetos donde vamos a tener nuestra tarea.
El atributo 'done' va a controlar si la tarea esta terminada o no.

El siguiente paso seria pintar esa tarea en pantalla.

Primero destructuramos el array dentro del render.

const { colorSelected, tasks } = this.state

Luego agrego un <div> y utilizando un '.map' recorremos el array para obtener las tareas.
Provisoriamente podemos mostrarlas dentro de un <p> pero en el siguiente paso debemos crear un componente para controlar esta funcionalidad.

<div>
    {
        tasks.map(task => (
            <p>{task.title}</p>
        ))
    }
</div>


Creamos un componente 'Task.jsx'
Creamos los styled-components necesarios:
- Un contenedor para cada tarea
- Un boton para borrar la tarea
- Un <p> que contendra el nombre de la tarea

Creamos nuestro componente tarea
Usamos una arrow function con return automatico porque este componente no necesita state.

const Task = () => (
    <TaskContainer>
        <input type="checkbox" />
        <TaskText></TaskText>
        <TaskButton>Delete</TaskButton>
    </TaskContainer>
)

El input checkbox nos sirve para controlar si la tarea se completo o no.
El texto de la tarea.
El boton para eliminarla.

Finalmente usamos este comoponente en lugar del <p> que habiamos usamos en nuestro App.jsx originalmente para hacer de vista previa.


7. Estilizando y rellenando el componente task

En nuestro 'App.jsx' le pasamos a nuestro componente <Task> las props que necesitamos e importamos 'shortid' para generar un id unico.

tasks.map(task => (
    <Task
        key={id()} 
        title={task.title}
        color={task.color}
    />
))

Una vez que tenemos listas las props (titulo y color) trabajamos en nuestro componente 'Task.jsx'

Primero destructuramos las props 'color' y 'title' para poder usarlas.
Dentro de <TaskText> le pasamos 'title' interpolado para que pueda leerlo.
El 'color' se lo tenemos que pasar a nuestro contenedor <TaskContainer>

const Task = ({ color, title }) => (
    <TaskContainer color={color}>
        <input type="checkbox" />
        <TaskText>{title}</TaskText>
        <TaskButton>Delete</TaskButton>
    </TaskContainer>
)


Ahora que <TaskContainer> ya tiene el 'color' lo podemos utilizar en nuestro 'TaskContainer' (styled-component) como prop.

const TaskContainer = styled.div`
    background-color: ${({color}) => color};
`


Solo resta darle estilos al componente...


8. Creando nuevas tareas

Añadir tareas a traves del formulario.
La informacion del formulario llega a 'handleSubmit'.
Por lo tanto, en 'handleSubmit' vamos a comprobar si 'e.target.title.value' es distinto de vacio (para saber si existe un texto dentro del input), de ser asi ejecutamos la funcion 'createNewTask' que se encargara de agregar tareas a nuestra lista.
'createNewTask' necesita como parametro el valor del input (e.target.title.value).


handleSubmit = (e) => {
        e.preventDefault()
        if(e.target.title.value.trim() !== ''){
            this.createNewTask(e.target.title.value)
        }
    }


Creamos la funcion que agregara las tareas ingresadas en el input a nuestra lista.

createNewTask = (title) => {
    const NewTask = {
        id: id(),
        title: title,
        color: this.state.colorSelected,
        done: false
    }

    const allTasks = [...this.state.tasks, NewTask]

    this.setState({tasks: allTasks})
}


Creamos un objeto que luego agregaremos al array de tareas.
Dentro del objeto necesitamos un id, titulo, el color que tendra la tarea y un booleano que indicara si la tarea esta completa o no.

Creamos un array donde tenemos las tareas que ya existen + la nueva! (Vamos agregando tareas)

Seteamos el state con el nuevo valor que se genera.
El nuevo valor para 'tasks' sera 'allTasks', esto es igual a las tareas que ya teniamos mas las que vayamos agregando.



9. Completando tareas

Marcar el 'checkbox' y que esta accion tache la tarea.

En nuestro app.jsx usamos una prop 'done={task.done}' para saber si la tarea esta completa (dentro del div donde se pintaran nuestra lista de tareas)

Esta prop la utilizamos en el componente Task.jsx (destructuramos la misma antes de usarla)

const Task = ({ color, title, done, handleCompleteTask }) => ()
<TaskText done={done}>{title}</TaskText>

Utilizando css tachamos la tarea en el caso que este completa.
Usamos text-decoration en el caso que este completa.
Destructuramos la prop 'done' y utilizando un ternario le indicamos tachado si es true o 'none' si es falso.

text-decoration:${({ done }) => done ? 'line-through' : 'none'};

En 'app.jsx' pasamos como prop 'handleCompleteTask' (la funcion que controla si una tarea se completo)

handleCompleteTask={() => this.handleCompleteTask(task.id)}

En 'Task.js' usamos 'onChange' para controlar el evento.
Cuando cambie (marcada/desmarcada) se activara.
Siempre destructurar la prop que vayamos a usar.

<input
    type="checkbox"
    onChange={handleCompleteTask}
    defaultChecked={done}
/>

Para finalizar y que quede marcado el 'checkbox' debemos usar 'defaultchecked' y la prop 'done'.


10. Borrando tareas

(El camino mas simple siempre sera crear una funcion para manejar un evento, pasar esta funcion como prop y asignarla donde queremos aplicarla (onClick/onChange/etc))


Creando la funcion para borrar tareas:

'filter' nos va a devolver un array. 
Quiero que me devuelva todas las que no coincidan con el 'id'

currentTasks = currentTasks.filter(task => task.id !== id)

Finalmente actualizamos el 'state' (con las tareas que quedan luego de filtrar la que eliminamos)


handleDeleteTask = (id) => {
    let currentTasks = this.state.tasks
    currentTasks = currentTasks.filter(task => task.id !== id)

    this.setState({ tasks: currentTasks })
}


Paso la funcion que creamos como prop dentro de la lista de tareas:

handleDeleteTask= { () => this.handleDeleteTask(task.id)}


Dentro de 'Task.jsx', en el boton 'delete' usamos un evento 'onClick' para pasar nuestra funcion:
(Previo destructurar la prop)

<TaskButton onClick={handleDeleteTask}>Delete</TaskButton>


Adicionales:

- Mostrar mensaje cuando no hay tareas

En 'app.jsx' renderizamos un mensaje si no hay tareas para mostrar.

{this.state.tasks.length === 0 && <h2>Not tasks yet</h2> }


- Borrar el contenido del input luego de agregar la tarea

Esta linea de codigo asignara 'vacio' al input luego que se crea una nueva tarea:
e.target.title.value = ''

handleSubmit = (e) => {
    e.preventDefault()
    if (e.target.title.value.trim() !== '') {
        this.createNewTask(e.target.title.value)
        e.target.title.value = ''
    }
}



11. Retoques finales



